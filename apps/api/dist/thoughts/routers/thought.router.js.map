{"version":3,"sources":["../../../src/thoughts/routers/thought.router.ts"],"sourcesContent":["import type { Thought } from '@prisma/client'\nimport { Input, Mutation, Query, Router } from 'nestjs-trpc'\nimport { z } from 'zod'\nimport { TRPCError } from '@trpc/server'\n\nimport {\n  createThoughtSchema,\n  editThoughtSchema,\n  thoughtSchema,\n} from '../thought.schema'\n\nimport { PrismaService } from '~/config/prisma'\n\n@Router({ alias: 'thought' })\nexport class ThoughtRouter {\n  constructor(private readonly prisma: PrismaService) {}\n\n  @Mutation({ input: createThoughtSchema, output: thoughtSchema })\n  async create(\n    @Input('content') content: Thought['content'],\n    @Input('authorId') authorId: Thought['authorId']\n  ) {\n    const { id } = await this.prisma.thought.create({\n      data: {\n        content,\n        author: {\n          connect: {\n            id: authorId,\n          },\n        },\n      },\n    })\n\n    return this.prisma.thought.findUnique({\n      where: {\n        id,\n      },\n      select: {\n        id: true,\n        content: true,\n        author: true,\n        createdAt: true,\n        updatedAt: true,\n      },\n    })\n  }\n\n  @Mutation({\n    input: editThoughtSchema,\n    output: thoughtSchema,\n  })\n  edit(\n    @Input('content') content: Thought['content'],\n    @Input('id') id: Thought['id']\n  ) {\n    return this.prisma.thought.update({\n      where: {\n        id,\n      },\n      data: {\n        content,\n      },\n      select: {\n        id: true,\n        content: true,\n        author: true,\n        createdAt: true,\n        updatedAt: true,\n      },\n    })\n  }\n\n  @Query({ input: z.string(), output: thoughtSchema })\n  async byId(@Input() id: string) {\n    const foundThought = await this.prisma.thought.findUnique({\n      where: {\n        id,\n      },\n      select: {\n        id: true,\n        content: true,\n        author: true,\n        createdAt: true,\n        updatedAt: true,\n      },\n    })\n\n    if (!foundThought) throw new TRPCError({ code: 'NOT_FOUND' })\n\n    return foundThought\n  }\n}\n"],"names":["ThoughtRouter","constructor","prisma","create","content","authorId","id","thought","data","author","connect","findUnique","where","select","createdAt","updatedAt","edit","update","byId","foundThought","TRPCError","code","input","createThoughtSchema","output","thoughtSchema","editThoughtSchema","z","string","alias"],"mappings":";;;;+BAcaA;;;eAAAA;;;4BAbkC;qBAC7B;wBACQ;+BAMnB;wBAEuB;;;;;;;;;;;;;;;AAGvB,IAAA,AAAMA,gBAAN,MAAMA;IACXC,YAAY,AAAiBC,MAAqB,CAAE;aAAvBA,SAAAA;IAAwB;IAErD,MACMC,OACJ,AAAkBC,OAA2B,EAC7C,AAAmBC,QAA6B,EAChD;QACA,MAAM,EAAEC,EAAE,EAAE,GAAG,MAAM,IAAI,CAACJ,MAAM,CAACK,OAAO,CAACJ,MAAM,CAAC;YAC9CK,MAAM;gBACJJ;gBACAK,QAAQ;oBACNC,SAAS;wBACPJ,IAAID;oBACN;gBACF;YACF;QACF;QAEA,OAAO,IAAI,CAACH,MAAM,CAACK,OAAO,CAACI,UAAU,CAAC;YACpCC,OAAO;gBACLN;YACF;YACAO,QAAQ;gBACNP,IAAI;gBACJF,SAAS;gBACTK,QAAQ;gBACRK,WAAW;gBACXC,WAAW;YACb;QACF;IACF;IAMAC,KACE,AAAkBZ,OAA2B,EAC7C,AAAaE,EAAiB,EAC9B;QACA,OAAO,IAAI,CAACJ,MAAM,CAACK,OAAO,CAACU,MAAM,CAAC;YAChCL,OAAO;gBACLN;YACF;YACAE,MAAM;gBACJJ;YACF;YACAS,QAAQ;gBACNP,IAAI;gBACJF,SAAS;gBACTK,QAAQ;gBACRK,WAAW;gBACXC,WAAW;YACb;QACF;IACF;IAEA,MACMG,KAAK,AAASZ,EAAU,EAAE;QAC9B,MAAMa,eAAe,MAAM,IAAI,CAACjB,MAAM,CAACK,OAAO,CAACI,UAAU,CAAC;YACxDC,OAAO;gBACLN;YACF;YACAO,QAAQ;gBACNP,IAAI;gBACJF,SAAS;gBACTK,QAAQ;gBACRK,WAAW;gBACXC,WAAW;YACb;QACF;QAEA,IAAI,CAACI,cAAc,MAAM,IAAIC,iBAAS,CAAC;YAAEC,MAAM;QAAY;QAE3D,OAAOF;IACT;AACF;;;QA1EcG,OAAOC,kCAAmB;QAAEC,QAAQC,4BAAa;;;;;;;;;;;;;QA+B3DH,OAAOI,gCAAiB;QACxBF,QAAQC,4BAAa;;;;;;;;;;;;;QAuBdH,OAAOK,MAAC,CAACC,MAAM;QAAIJ,QAAQC,4BAAa;;;;;;;;;;;QA3DzCI,OAAO"}